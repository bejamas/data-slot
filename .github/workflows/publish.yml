name: Publish to npm

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Dry run (skip actual publish)"
        required: false
        default: false
        type: boolean

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history needed for release notes generation

      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run tests
        run: bun test

      - name: Build packages
        run: bun run build

      - name: Setup npm auth
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          if [ -z "$NPM_TOKEN" ]; then
            echo "ERROR: NPM_TOKEN secret is not set!"
            exit 1
          fi
          echo "//registry.npmjs.org/:_authToken=$NPM_TOKEN" > ~/.npmrc
          # Verify npm can authenticate (this will fail if token is invalid)
          npm whoami

      - name: Publish packages
        if: ${{ !inputs.dry_run }}
        run: |
          set -euo pipefail

          # Helper function: pack with bun, validate packed manifest, then publish extracted contents.
          publish_pkg() {
            local dir="$1"
            pushd "$dir" >/dev/null

            rm -f ./*.tgz
            bun pm pack >/dev/null

            local tgz
            tgz="$(ls -1 *.tgz | head -n1)"
            [ -f "$tgz" ] || { echo "No .tgz produced in $dir"; ls -la; exit 1; }

            local tmp
            tmp="$(mktemp -d)"
            tar -xzf "$tgz" -C "$tmp"

            echo "=== Packed manifest for $dir ($tgz) ==="
            cat "$tmp/package/package.json"

            npm publish "$tmp/package" --access public --provenance

            rm -rf "$tmp"
            rm -f "$tgz"
            popd >/dev/null
          }

          # Publish in dependency order (core first)
          # publish_pkg packages/core
          publish_pkg packages/accordion
          publish_pkg packages/dialog
          publish_pkg packages/collapsible
          publish_pkg packages/navigation-menu
          publish_pkg packages/popover
          publish_pkg packages/tabs
          publish_pkg packages/tooltip
          publish_pkg packages/dropdown-menu
          publish_pkg packages/slider
          publish_pkg packages/toggle
          publish_pkg packages/toggle-group
          publish_pkg packages/select
          publish_pkg packages/combobox

      - name: Dry run - show what would be published
        if: ${{ inputs.dry_run }}
        run: |
          echo "Would publish the following packages:"
          for pkg in packages/*/; do
            name=$(jq -r .name "$pkg/package.json")
            version=$(jq -r .version "$pkg/package.json")
            echo "  $name@$version"
          done

      - name: Generate Release Notes
        if: ${{ !inputs.dry_run && startsWith(github.ref, 'refs/tags/') }}
        id: release_notes
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "OPENAI_API_KEY not set, using default release notes"
            echo "use_default=true" >> $GITHUB_OUTPUT
          else
            bun run scripts/generate-release-notes.ts ${{ github.ref_name }} > release-notes.md
            echo "use_default=false" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Release
        if: ${{ !inputs.dry_run && startsWith(github.ref, 'refs/tags/') }}
        uses: softprops/action-gh-release@v2
        with:
          body_path: ${{ steps.release_notes.outputs.use_default == 'false' && 'release-notes.md' || '' }}
          generate_release_notes: ${{ steps.release_notes.outputs.use_default == 'true' }}
